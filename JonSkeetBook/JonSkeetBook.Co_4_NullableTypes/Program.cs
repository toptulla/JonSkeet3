using System;

namespace JonSkeetBook.Co_4_NullableTypes
{
    /*
     
     + Причины использования null значений
     
     Является ли null значением или же это отсутсвие значения? Это "ничеги" или это "что-то"?
     Должны ли языки поддерживть null концепцию или она должна быть представлена в других паттернах?
     
     В этой главе мы сконцентрируемся на прикладных вещах, а не филосовских:
     Почему в C# 1 вы не можете установить переменной значимого типа значение null и какие традиционные
     альтернативы этому есть. Затем я представлю вам нашего рыцаря в сияющх доспехах - System.Nullable<T>
     и мы посмотрим, как C# 2 делает работу с nullable типами проще и компактнее. Как и обобщения nullable
     типы иногда используются в ситуацих, которые выходят за рамки ожидаемых, вы рассморим это в конце
     главы.
     
     Когда значение - не значение?
     Что делать когда значение просто отсутствует?
     I need to set my DateTime variable to null, but the compiler won’t let me. What should I do?
     
     Значением переменной ссылочного типа является ссылка, в то время, как значением переменной значимого типа,
     являются непосредственно данные. Для ссылочных типов null - это специалное значение, например ссылка
     может хранить 2 в 32 степени значений, когда все биты 0 - это значение null. Другими словами, непосредст-
     венно на значения ссылки отводится |2 в 32 - 1| значений, одно значение (когда все биты 0) - это null.
     Для значимого типа такое поведение не приемлимо, значение может занимать очень много памяти. Например,
     значение значимого типа занимает 2 Мб, и если у нас есть 1000 null объектов, то все они занимают 2000 Мб!
     Большой кусок памяти расходуется зря. Кроме того и самое главное значение 0 занято!!!
     Например, возьмем тип byte - 1 байт, 0-255. Если мы используем значение 0, как null, то тогда мы не
     сможем задать этой переменной значение 0, как значение!
     Для значимых переменных нам необходим полный диапазон значений!!!
     
     Зачем нам вообще понадобилась возможность пердставлять null типом значения? Самой распространенной
     причиной является, то, что базы данных поддерживают значение NULL для каждого типа - символьные данные,
     целые числа, булевые значения и т.д. (если, конечно, поле специально не помечено, как не допускающее
     значение NULL). И если при выборке данных мы не хотим терять информацию, то нам необходима возможность
     каким-то образом представлять значения null в наших типах.
     
     Хорошо, тогда зачем в базах данных разрешены значения null? На самом деле типы значений допускающие null
     удобны в определенных сценариях - когда значение еще не известно или оно отсутствует.
     
     
     
     
     
     + Поддержка nullable типов фреймворком и рантаймом
     
     Основной структурой, которая лежит в основе nullable типов, является структура System.Nullable<T>.
     В дополнение к ней, существует статический класс System.Nullable, который содержит служебные методы,
     которые упрошают работу с nullable типами.

     Nullable<T> является обобщенным. Параметр Т имеет ограничение типа значения. Вы не можете например
     написать следующее - Nullable<Strean>, т.к. тип Stream относится к ссылочному типу данных, а на 
     Nullable<T> ограничение - Т, может быть только значимым типом. Кроме того, нельзя написать вот так:
     Nullable<Nullable<T>>, это запрещено, хотя Nullable<T> и является значимым типом.
     
     Nullable<T> неизменяемый, т.е. он спроектирован так, что его экземпляр не может быть изменен после
     конструирования.
     
     Метод GetValueOrDefault() - значение экземпляра, если оно есть, иначе значение по умолчанию.
     Метод GetHashCode() - 0, если значения нет, и результат GetHashCode() на значении, если оно есть.
     Метод ToString() - пустую строку, если значения нет, и результат ToString() на значении, если оно есть.
     
     Инфраструктура предоставляет неявное преобразование из T в Nullable<T> и явное из Nullable<T> в Т. В
     спецификации C# процесс преобразования из Т в Nullable<T> называется WRAPPING, а из Nullable<T> в Т
     UNWRAPPING. Спецификация определяет эти термины со ссылкой на конструктор с параметром и свойство
     Value, соотвественно. На самом деле эти вызовы генерируются C# кодом всегда, даже если это выглядит,
     как преобразование, предоставляемое инфраструктурой.
     
     Тип Nullable<T> является структурой - значимым типом, следовательно, если вы захотите преобразовать его
     в ссылочный тип, то вам пондобится его упаковка. У CLR есть специальные правила по упаковке и распаковке
     Nullable<T>, эти правила отличаются от правил упаковки/распаковки обычных значимых типов (по началу все
     планировалсь сделать как обычно, но перед выходом .NET 2.0 сообщество потребовало изменить реализацию).
     Экземпляр Nullable<T> упаковывается в пустую ссылку - null, если у него нет значения или в упакованное
     знеачение типа Т, если у него есть значение. Упаковка никогда не осуществляется в упакованный тип
     Nullable<T>, это либо null, либо упакованный экземпляр типа Т.
     Вы можете распаковать упакованное значение либо в его базовый тип, либо в Nullable<T>. Распаковка ссылки
     на null приведет к исключению NullRefferenceException, в случае, если вы распаковываете в базовый тип Т.
     Если вы распаковываете null ссылку в Nullable<T>, будет создан экземпляр Nullable<T> с HasValue = False.
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     Языковая поддрежка nullable типов в C# 2
     
     
     
     
     
     
     
     
     
     
     Паттерны использования nullable типов
     
     
     
     
     
     
     
     
     
     
    */

    class Program
    {
        static void Main()
        {
            //NullableClass();
            Console.ReadLine();
        }

        static void NullableClass()
        {
            Console.WriteLine(Nullable.Compare<int>(new int?(10), new int?(11))); ;
        }

        static void OverridedObjectEquals()
        {
            int? a = null;
            int? b = null;

            int? a1 = null;
            int? b1 = 5;

            int? a2 = 5;
            int? b2 = null;

            int? a3 = 5;
            int? b3 = 5;

            Console.WriteLine(null == null); // True
            Console.WriteLine(a.Equals(b)); // True
            Console.WriteLine(a1.Equals(b1)); // False
            Console.WriteLine(a2.Equals(b2)); // False
            Console.WriteLine(a3.Equals(b3)); // True
        }

        static void OverridedObjectEqualsBoxingUnboxing()
        {
            Nullable<int> nullable = 5;
            object boxed = nullable;
            Console.WriteLine(boxed.GetType()); // System.Int32

            int normal = (int)boxed;
            Console.WriteLine(normal); // 5

            nullable = (Nullable<int>)boxed;
            Console.WriteLine(nullable); //  5

            nullable = new Nullable<int>();
            boxed = nullable;
            Console.WriteLine(boxed == null); // True

            nullable = (Nullable<int>)boxed;
            Console.WriteLine(nullable.HasValue); // False
        }

        static void FirstLook()
        {
            Nullable<int> x = 5;
            x = new Nullable<int>(5);
            Console.WriteLine("Instance with value.");
            Display(x);

            x = new Nullable<int>();
            Console.WriteLine("Instance without value.");
            Display(x);
        }

        static void Display(Nullable<int> x)
        {
            if (x.HasValue)
            {
                Console.WriteLine($"HasValue: {x.HasValue}");
                Console.WriteLine($"Explicit conversion: {(int)x}");
            }

            Console.WriteLine($"GetValueOrDefault(): {x.GetValueOrDefault()}");
            Console.WriteLine($"GetValueOrDefault(10): {x.GetValueOrDefault(10)}");
            Console.WriteLine($"ToString(): {x.ToString()}");
            Console.WriteLine($"GetHashCode(): {x.GetHashCode()}");
            Console.WriteLine();
        }
    }
}
