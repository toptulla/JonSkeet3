using System;

namespace JonSkeetBook.Co_2_1_Delegates
{
    /*
    Делегаты обеспечивают уровень косвенного обращения: вместо того чтобы определить действие,
    которое будет выполнено непосредственно, его можно упаковать в объект. Затем этот объект
    может быть использован как и любой другой, а одной из операций, которую вы можете осуществить
    c ним - это выполнение инкапсулируемого действия.
    * 
    Можно считать тип делегата - интерфейсом одного метода, а экземпляр делегата - объектом,
    реализующим этот интерфейс.
    * 
    Следует знать, что экземпляр делегата будет препятствовать удалению своей цели 
    при сборе "мусора", если сам экземпляр делегата не может быть собран. Это может  
    привести к утечке памяти, особенно когда "недолговечный" объект подписался на событие 
    "долговечного" объекта, используя себя как цель. Долговечный объект косвенно  
    удерживает ссылку на недолговечный объект, продлевая его существование. 
     
    Зачем нужны делегаты?
    Для того чтобы у нас была возможность разрешить ситуацию, когда код должен выполнить действия, не зная
    точно, каковы эти действия должны быть. Например, единчтвенная причина, по которой класс Thread значет,
    что при запуске нужно работать в новом потоке, - это прелоставленный вами конструктор с экземпляром
    делегата ThreadStart или ParametrizedThreadStart.
     
    Рецепт простых делегатов:
    1 Тип делегата должен быть объявлен.
    2 Должен существовать метод, содержащий код для выполнения.
    3 Экземпляр делегата должен быть создан.
    4 Экземпляр делегата должен быть вызван.

    Любой создаваемый тип делегата неявно наследуется от System.MulticastDelegate, который, в свою очередь, наследуется
    от System.Delegate.
                            [делегат] -> System.MulticastDelegate -> System.Delegate
    
    Понятия:
        - Тип делегата
        - Экземпляр типа делегата
    
    Следует знать, что экземпляр делегата будет препятствовать удалению своей цели 
    при сборе "мусора", если сам экземпляр делегата не может быть собран. Это может  
    привести к утечке памяти, особенно когда "недолговечный" объект подписался на событие 
    "долговечного" объекта, используя себя как цель. Долговечный объект косвенно  
    удерживает ссылку на недолговечный объект, продлевая его существование.

    */

    class Program
    {
        private delegate void StringProcessor(string s);
        
        static void Main()
        {
            StringProcessor sp1 = new StringProcessor(PrintString1);
            StringProcessor sp2 = new StringProcessor(PrintString2);

            var sp = (StringProcessor)Delegate.Combine(sp1, sp2);
            sp.Invoke("s");
            
            Console.ReadLine();
        }

        private static void PrintString1(string s)
        {
            Console.WriteLine($"string: {s}");
        }

        private static void PrintString2(object s)
        {
            Console.WriteLine($"object: {s}");
        }
    }
}
